%%%-------------------------------------------------------------------
%%% Problem 12
%%% The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
%%% 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
%%% Let us list the factors of the first seven triangle numbers:
%%% 1: 1
%%% 3: 1,3
%%% 6: 1,2,3,6
%%% 10: 1,2,5,10
%%% 15: 1,3,5,15
%%% 21: 1,3,7,21
%%% 28: 1,2,4,7,14,28
%%% We can see that 28 is the first triangle number to have over five divisors.
%%% What is the value of the first triangle number to have over five hundred divisors?
%%%-------------------------------------------------------------------
-module(problem_12).
-author("akli").

%% API
-export([result/0]).

result() ->
  triangle_factors({1, 1}, [2]).

triangle_factors({T, Last}, Primes) ->
  UpdatedPrimes = fill_primes(Primes, trunc(math:sqrt(T)) + 1),
  PrimeFactors = num_to_prime_factors(T, UpdatedPrimes),
  FactorsCount = lists:foldl(fun(Elem, Acc) -> Acc * (Elem + 1) end, 1, maps:values(PrimeFactors)),
  if
    FactorsCount < 500 -> triangle_factors(next_triangle({T, Last}), UpdatedPrimes);
    true -> {T, FactorsCount}
  end.

next_triangle({Sum, Last}) ->
  case {Sum + Last + 1, Last + 1} of
    {NextSum, NextLast} when NextSum rem 2 == 1 -> next_triangle({NextSum, NextLast});
    Triangle -> Triangle
  end.

num_to_prime_factors(Number, Primes) -> num_to_prime_factors(Number, Primes, maps:new()).

num_to_prime_factors(1, _, PrimeFactors) -> PrimeFactors;
num_to_prime_factors(_, [], PrimeFactors) -> PrimeFactors;
num_to_prime_factors(Number, Primes = [HPrime|RestPrimes], PrimeFactors) ->
  case Number rem HPrime of
    0 ->
      NewPrimesFactors = PrimeFactors#{ HPrime => maps:get(HPrime, PrimeFactors, 0) + 1 },
      num_to_prime_factors(Number div HPrime, Primes, NewPrimesFactors);
    _ -> num_to_prime_factors(Number, RestPrimes, PrimeFactors)
  end.

fill_primes(Primes = [H|_], Max) when H > Max ->
  Primes;
fill_primes(Primes = [H|_], Max) ->
  fill_primes(H+1, Primes, Max).

fill_primes(Next, Primes, Max) ->
  case check_is_prime(Next, Primes) of
    true -> fill_primes([Next|Primes], Max);
    false -> fill_primes(Next + 1, Primes, Max)
  end.

check_is_prime(Next, Primes) ->
  Divisors = [P || P <- Primes, P < trunc(math:sqrt(Next)) + 1],
  not divides_by_any(Next, lists:reverse(Divisors)).

divides_by_any(_, []) -> false;
divides_by_any(Next, [Divisor|Rest]) ->
  case Next rem Divisor of
    0 -> true;
    _ -> divides_by_any(Next, Rest)
  end.